<!DOCTYPE html>
{% load static %}
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Experiment 1 - TCIN</title>

  <link rel="stylesheet" href="https://js.arcgis.com/4.28/esri/themes/light/main.css" />
  <script src="https://js.arcgis.com/4.28/"></script>
  <script src="https://code.jquery.com/jquery-1.12.4.js"></script>

  <style>
    html,
    body,
    #viewDiv {
      width: 91%;
      height: 100%;
      top: 0;
      margin-left: auto;
      margin-right: auto;
      padding: 0;
      display: flex;
      justify-content: center;
      /* align-items: center; */
    }
    /* #logoDiv {
      position: : fixed;
      padding: 12px;
      background-color: black;
      bottom: 0;
      right: 0;
      color: pink;
      text-align: center;
      width: 100px;
      height: auto;
    } */
    #droneControl {
      position: fixed;
      top: 30%;
      right: 0;
      height: auto;
      background: rgba(255,255,255, 0.9);
      width: 226px;
      /* padding: 5px; */
    }
    #droneRatings {
      /* position: absolute; */
      position: fixed;
      bottom: 0;
      left: 0;
      width: 215px;
      height: auto;
      background: rgba(255,255,255, 0.9);
      padding: 5px;
    }
    #droneSelectionForm {
      position: fixed;
      top: 0;
      right: 0;
      width: 226px;
      height: auto;
      background: rgba(255,255,255, 0.9);
      /* display: flex; */
      /* flex-direction: column; /* This will stack the fields vertically */ */
      padding: 5px;
    }
    #droneSelectionForm > div {
      margin-bottom: 5px; /* Adds space between the form elements */
    }
    #submitBtn {
      width: 40%; /* Smaller width */
      margin: 0 auto; /* Center the button */
    }
    #droneQuadrantDisplay {
      display: none; /* Initially hidden */
      position: fixed;
      top: 0;
      right: 0;
      width: 226px;
      background: rgba(255,255,255,0.9);
      padding: 2px;
      /* z-index: 10; */
    }
    .quadrant-info {
      margin-bottom: 8px;
    }
    hr {
      border: 0;
      height: 1px;
      background: #ccc; /* Light grey line */
      margin: 10px 0; /* Spacing above and below the line */
    }
    .competence-slider {
      /* appearance: none; /* removes browser-specific styling */ */
      width: 200px; /* width of slider */
      height: 00px; /* height of slider */
      background: #000 10%;
      outline: none; /* remove outline */
      border-radius: 50px; /* round corners */
    }
    datalist {
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      writing-mode: vertical-lr;
      width: 200px;
    }

    option {
      padding: 0;
      /* writing-mode: vertical-rl;
      text-orientation: upright;       */
    }

    input[type="range"] {
      width: 200px;
      margin: 0;
    }

  </style>
  </style>

  <script>
    require([
      "esri/Map",
      "esri/views/MapView",
      "esri/Graphic",
      "esri/geometry/Point",
      "esri/geometry/Polyline",
      "esri/widgets/Expand",
      "esri/widgets/Search",
      "esri/geometry/Polygon"
    ], (Map, MapView, Graphic, Point, Polyline, Expand, Search, Polygon) => {
      const map = new Map({
        basemap: "hybrid"
      });

      const view = new MapView({
        center: [-85, 35],
        container: "viewDiv",
        map: map,
        zoom: 13
      });

      // Assuming gridSize is the size of your grid cells
      const gridSize = 0.005; // Size of each grid cell in some unit

      // Dynamic size of drones based on gridSize
      const droneSymbolSize = `${0.25 * 100}px`; // Convert gridSize to pixels if necessary

     // Define the symbol for drawing the points
      const markerSymbol1 = {
        type: "picture-marker",
        url: "{% static 'img/thermal-drone.png' %}",
        width: droneSymbolSize,
        height: droneSymbolSize
        // width: "30px",
        // height: "30px"
      };

      const markerSymbol2 = {
        type: "picture-marker",
        url: "{% static 'img/sniffer-drone.png' %}",
        width: droneSymbolSize,
        height: droneSymbolSize
        // width: "30px",
        // height: "30px"
      };

      // Create multiple point graphics - Drones
      const pointGraphics = [
        new Graphic({
          geometry: new Point({ longitude: -84.9975, latitude: 35.0025 }), // Quadrant 1
          symbol: markerSymbol1,
          attributes: { id: "drone1"}
        }),
        new Graphic({
          geometry: new Point({ longitude: -85.0025, latitude: 35.0025 }), // Quadrant 2
          symbol: markerSymbol1,
          attributes: { id: "drone2"}
        }),
        new Graphic({
          geometry: new Point({ longitude: -85.0025, latitude: 34.9975 }), // Quadrant 3
          symbol: markerSymbol2,
          attributes: { id: "drone3"}
        }),
        new Graphic({
          geometry: new Point({ longitude: -84.9975, latitude: 34.9975 }), // Quadrant 4
          symbol: markerSymbol2,
          attributes: { id: "drone4"}
        })
      ];

      //Line 1 - Xaxis
      const Xaxis = {
           type: "polyline", // autocasts as new Polyline()
           paths: [[-85.1, 35], [-84.8948, 35]]
         };

      // Line 2 - Yaxis
      const Yaxis = {
           type: "polyline", // autocasts as new Polyline()
           paths: [[-85, 34.95], [-85, 35.05]]
         };

      // Symbol for drawing the lines
      const lineSymbol = {
           type: "simple-line", // autocasts as SimpleLineSymbol()
           color: [226, 119, 40],
           width: 4
         };

      // Symbol for grid lines
      const gridLineSymbol = {
             type: "simple-line",
             color: [0, 0, 0, 0.3], // Semi-transparent black
             width: "1px"
           };

      const XaxisGraphic = new Graphic({
           geometry: Xaxis,
           symbol: lineSymbol
         });

      const YaxisGraphic = new Graphic({
           geometry: Yaxis,
           symbol: lineSymbol
         });

      // Function to create a grid in a quadrant
      function createGrid(xStart, yStart, xEnd, yEnd, cellSize) {
           const gridGraphics = [];
           for (let x = xStart; x < xEnd; x += cellSize) {
             for (let y = yStart; y < yEnd; y += cellSize) {
               const cell = new Polygon({
                 rings: [
                   [
                     [x, y],
                     [x + cellSize, y],
                     [x + cellSize, y + cellSize],
                     [x, y + cellSize],
                     [x, y] // Close the polygon
                   ]
                 ]
               });

               const cellGraphic = new Graphic({
                 geometry: cell,
                 symbol: {
                   type: "simple-fill",
                   color: [0, 0, 0, 0], // Transparent fill
                   outline: gridLineSymbol
                 }
               });

               gridGraphics.push(cellGraphic);
             }
           }
           return gridGraphics;
         }

      // Create grids for each quadrant
      // const gridSize = 0.5; // Size of each grid cell
      const quadrant1 = createGrid(-85, 35, -84.9, 35.05, gridSize);
      const quadrant2 = createGrid(-85.1, 35, -85, 35.05, gridSize);
      const quadrant3 = createGrid(-85.1, 34.95, -85, 35, gridSize);
      const quadrant4 = createGrid(-85, 34.95, -84.9, 35, gridSize);

      // Add the point graphics to the view's graphics layer
         view.graphics.addMany([...quadrant1, ...quadrant2, ...quadrant3, ...quadrant4, ...pointGraphics, XaxisGraphic, YaxisGraphic]);

      // //Create detection points for drones
      // const objectDetectionPoints = {
      //   drone1: [
      //     { longitude: -84.5, latitude: 35.5 },
      //     { longitude: -84.25, latitude: 39.5 }
      //   ],
      //   drone2: [
      //     { longitude: -85.5, latitude: 35.5 },
      //     { longitude: -85.75, latitude: 39.5 }
      //   ],
      //   drone3: [
      //     { longitude: -85.5, latitude: 34.5 },
      //     { longitude: -85.75, latitude: 30.5 }
      //   ],
      //   drone4: [
      //     { longitude: -84.5, latitude: 34.5 },
      //     { longitude: -84.25, latitude: 30.5 }
      //   ]
      // };

      function assignDronesToQuadrants() {
          const quadrant1Drone = document.getElementById('quadrant1').value;
          const quadrant2Drone = document.getElementById('quadrant2').value;
          const quadrant3Drone = document.getElementById('quadrant3').value;
          const quadrant4Drone = document.getElementById('quadrant4').value;

          // Clear the previous quadrant assignments
          Object.keys(dronePathsTrack).forEach(droneId => {
              dronePathsTrack[droneId].quadrant = null;
              dronePathsTrack[droneId].path = [];
              dronePathsTrack[droneId].objectDetectionPoints = [];
          });

          // Update the dronePathsTrack object with the new assignments and paths
          dronePathsTrack[quadrant1Drone].quadrant = 'quadrant1';
          dronePathsTrack[quadrant1Drone].path = generateLawnmowerPatternQuadrant1(-84.9975, 35.0025);
          dronePathsTrack[quadrant1Drone].objectDetectionPoints = objectDetectionPoints['drone1']; // Object detection points are attached to each quadrant
          console.log(quadrant1Drone);

          dronePathsTrack[quadrant2Drone].quadrant = 'quadrant2';
          dronePathsTrack[quadrant2Drone].path = generateLawnmowerPatternQuadrant2(-85.0025, 35.0025);
          dronePathsTrack[quadrant2Drone].objectDetectionPoints = objectDetectionPoints['drone2'];
          console.log(quadrant2Drone);

          dronePathsTrack[quadrant3Drone].quadrant = 'quadrant3';
          dronePathsTrack[quadrant3Drone].path = generateLawnmowerPatternQuadrant3(-85.0025, 34.9975);
          dronePathsTrack[quadrant3Drone].objectDetectionPoints = objectDetectionPoints['drone3'];
          console.log(quadrant3Drone);

          dronePathsTrack[quadrant4Drone].quadrant = 'quadrant4';
          dronePathsTrack[quadrant4Drone].path = generateLawnmowerPatternQuadrant4(-84.9975, 34.9975);
          dronePathsTrack[quadrant4Drone].objectDetectionPoints = objectDetectionPoints['drone4'];
          console.log(quadrant4Drone);
      }



      // Function to assign drones to quadrants based on user input and update their positions immediately
      function assignDronesToQuadrantsAndUpdatePositions() {
        assignDronesToQuadrants();

        // Immediately update drones' positions to the start of their paths before animation starts
        pointGraphics.forEach(graphic => {
          const droneId = graphic.attributes.id;
          const droneInfo = dronePathsTrack[droneId];
          if (droneInfo && droneInfo.path.length > 0) {
            const startPoint = droneInfo.path[0]; // Assuming the path is an array of [longitude, latitude]
            graphic.geometry = new Point({
              longitude: startPoint[0], // Use the first element of the startPoint array for longitude
              latitude: startPoint[1] // Use the second element of the startPoint array for latitude
            });
          }
        });

        // Update the map with the new positions
        updateMap();
      }

      // Function to update the map with the assigned drone positions
      function updateMap() {
        // Refresh the graphics on the view
        view.graphics.removeAll();
        view.graphics.addMany([...quadrant1, ...quadrant2, ...quadrant3, ...quadrant4, ...pointGraphics, XaxisGraphic, YaxisGraphic]);
      }

      // Global variable to store the timestamp
      let reassignmentTimestamp = null;

      document.getElementById('droneSelectionForm').addEventListener('submit', function(event) {
          event.preventDefault(); // Prevent the form from submitting normally
          assignDronesToQuadrantsAndUpdatePositions();
          updateMap(); // Update the map after assigning drones to quadrants

          reassignmentTimestamp = new Date().toISOString();
      });

      // Function to select object detection points from a drone's path
      function selectObjectDetectionPointsFromPath(dronePath, count) {
          let selectedPoints = [];
          let pathLength = dronePath.length;

          // Ensure there are enough points in the path
          if (count > pathLength) {
              console.error("Requested more detection points than available in the path.");
              return selectedPoints;
          }

          // Randomly select 'count' unique indices from the drone path
          let selectedIndices = new Set();
          while (selectedIndices.size < count) {
              let randomIndex = Math.floor(Math.random() * pathLength);
              selectedIndices.add(randomIndex);
          }

          // Add the points at the selected indices to the selectedPoints array
          selectedIndices.forEach(index => {
              selectedPoints.push(dronePath[index]);
          });

          return selectedPoints;
      }

      let drone1Path = generateLawnmowerPatternQuadrant1(-84.9975, 35.0025);
      let drone2Path = generateLawnmowerPatternQuadrant2(-85.0025, 35.0025);
      let drone3Path = generateLawnmowerPatternQuadrant3(-85.0025, 34.9975);
      let drone4Path = generateLawnmowerPatternQuadrant4(-84.9975, 34.9975);

      // Assign random object detection points to each drone
      const objectDetectionPoints = {
          drone1: selectObjectDetectionPointsFromPath(drone1Path, 5), // Quadrant 1
          drone2: selectObjectDetectionPointsFromPath(drone2Path, 5), // Quadrant 2
          drone3: selectObjectDetectionPointsFromPath(drone3Path, 5), // Quadrant 3
          drone4: selectObjectDetectionPointsFromPath(drone4Path, 5)  // Quadrant 4
      };

      // Define paths for each drone to follow
      const dronePaths = {
        drone1: {
          path: generateLawnmowerPatternQuadrant1(-84.9975, 35.0025),
          objectDetectionPoints: objectDetectionPoints.drone1
        },
        drone2: {
          path: generateLawnmowerPatternQuadrant2(-85.0025, 35.0025),
          objectDetectionPoints: objectDetectionPoints.drone2
        },
        drone3: {
          path: generateLawnmowerPatternQuadrant3(-85.0025, 34.9975),
          objectDetectionPoints: objectDetectionPoints.drone3
        },
        drone4: {
          path: generateLawnmowerPatternQuadrant4(-84.9975, 34.9975),
          objectDetectionPoints: objectDetectionPoints.drone4
        },
      };

      // Global object to track drone paths and object detection points initialized with paths and object detection points
      var dronePathsTrack = {
        drone1: {
          path: dronePaths.drone1,
          objectDetectionPoints: objectDetectionPoints.drone1,
          quadrant: 'quadrant1',
          recentlyReassigned: false, // Initialize as false
          reassignmentTime: 0, // Initialize with a default value
          imagingType: 'thermal'
        },
        drone2: {
            path: dronePaths.drone2,
            objectDetectionPoints: objectDetectionPoints.drone2,
            quadrant: 'quadrant2',
            recentlyReassigned: false,
            reassignmentTime: 0,
            imagingType: 'thermal'
        },
        drone3: {
            path: dronePaths.drone3,
            objectDetectionPoints: objectDetectionPoints.drone3,
            quadrant: 'quadrant3',
            recentlyReassigned: false,
            reassignmentTime: 0,
            imagingType: 'nswir',
        },
        drone4: {
            path: dronePaths.drone4,
            objectDetectionPoints: objectDetectionPoints.drone4,
            quadrant: 'quadrant4',
            recentlyReassigned: false,
            reassignmentTime: 0,
            imagingType: 'nswir',
        }
      };

      // // Array to store the ratings
      // let ratings = [];

      // Print the object detection points for each drone
      console.log("Q1 Object Detection Points:", objectDetectionPoints.drone1);
      console.log("Q2 Object Detection Points:", objectDetectionPoints.drone2);
      console.log("Q3 Object Detection Points:", objectDetectionPoints.drone3);
      console.log("Q4 Object Detection Points:", objectDetectionPoints.drone4);

      // Function to generate lawnmower pattern for quadrant 1
      function generateLawnmowerPatternQuadrant1(startX, startY) {
        let path = [];
        let moveRight = true; // Start by moving right
        for (let y = startY; y <= 35.05; y += gridSize) {
          if (moveRight) {
            for (let x = startX; x <= -84.9; x += gridSize) {
              path.push([x, y]);
            }
          } else {
            for (let x = -84.9; x >= startX; x -= gridSize) {
              path.push([x, y]);
            }
          }
          moveRight = !moveRight; // Toggle direction
        }
        console.log("Q1 Path:", path)
        return path;
      }


      // Function to generate lawnmower pattern for quadrant 2
      function generateLawnmowerPatternQuadrant2(startX, startY) {
        let path = [];
        let moveLeft = true; // Start by moving left
        for (let y = startY; y <= 35.05; y += gridSize) {
          if (moveLeft) {
            for (let x = startX; x >= -85.1; x -= gridSize) {
              path.push([x, y]);
            }
          } else {
            for (let x = -85.1; x <= startX; x += gridSize) {
              path.push([x, y]);
            }
          }
          moveLeft = !moveLeft; // Toggle direction
        }
        console.log("Q2 Path:", path)
        return path;
      }

      // Function to generate lawnmower pattern for quadrant 3
      function generateLawnmowerPatternQuadrant3(startX, startY) {
        let path = [];
        let moveLeft = true; // Start by moving left
        for (let y = startY; y >= 34.95; y -= gridSize) {
          if (moveLeft) {
            for (let x = startX; x >= -85.1; x -= gridSize) {
              path.push([x, y]);
            }
          } else {
            for (let x = -85.1; x <= startX; x += gridSize) {
              path.push([x, y]);
            }
          }
          moveLeft = !moveLeft; // Toggle direction
        }
        console.log("Q3 Path:", path)
        return path;
      }

      // Function to generate lawnmower pattern for quadrant 4
      function generateLawnmowerPatternQuadrant4(startX, startY) {
        let path = [];
        let moveRight = true; // Start by moving right
        for (let y = startY; y >= 34.95; y -= gridSize) {
          if (moveRight) {
            for (let x = startX; x <= -84.9; x += gridSize) {
              path.push([x, y]);
            }
          } else {
            for (let x = -84.9; x >= startX; x -= gridSize) {
              path.push([x, y]);
            }
          }
          moveRight = !moveRight; // Toggle direction
        }
        console.log("Q4 Path:", path)
        return path;
      }

      // Function to change drone color for 10 seconds upon detecting an object
      function changeDroneColorOnDetection(droneGraphic) {
        // Clone the original symbol to preserve its properties
        const originalSymbol = {
            type: droneGraphic.symbol.type,
            url: droneGraphic.symbol.url,
            width: droneGraphic.symbol.width,
            height: droneGraphic.symbol.height,
            // Include any other properties that are relevant to your symbol
        };

        // Define a new symbol with a different color or image to indicate detection
        const detectionSymbol = {
          type: "picture-marker",
          url: "{% static 'img/target.png' %}",
          width: droneSymbolSize,
          height: droneSymbolSize
          // color: "red" // Change the color to red or any other color
        };

        // Change the drone's symbol to the detection symbol
        droneGraphic.symbol = detectionSymbol;

        // Update the graphic on the map
        view.graphics.remove(droneGraphic);
        view.graphics.add(droneGraphic);

        // Revert back to the original symbol after 10 seconds
        setTimeout(() => {
            droneGraphic.symbol = originalSymbol;
            view.graphics.remove(droneGraphic);
            view.graphics.add(droneGraphic);
        }, 10000);
      }

      // Function to update the quadrant display with the current drones
      function updateQuadrantDisplay() {
          var display = document.getElementById('droneQuadrantDisplay');
          display.innerHTML = ''; // Clear existing content
          var heading = document.createElement('h3');
          heading.textContent = 'Current Drone Assignment';
          display.appendChild(heading);
          var hr = document.createElement('hr');
          display.appendChild(hr);

          // Define the order of quadrants explicitly
          var quadrantsOrder = ['quadrant1', 'quadrant2', 'quadrant3', 'quadrant4'];

          // Iterate over the quadrants in the defined order
          quadrantsOrder.forEach(function(quadrant) {
              // Assuming dronePathsTrack[droneId].quadrant holds the quadrant assignment
              var droneId = Object.keys(dronePathsTrack).find(key => dronePathsTrack[key].quadrant === quadrant);
              var div = document.createElement('div');
              div.textContent = `${quadrant}: ${droneId}`;
              display.appendChild(div);
          });
      }

      // const quadrant1Drone = document.getElementById('quadrant1').value;
      // const quadrant2Drone = document.getElementById('quadrant2').value;
      // const quadrant3Drone = document.getElementById('quadrant3').value;
      // const quadrant4Drone = document.getElementById('quadrant4').value;
      //
      // const displayElement = document.getElementById('droneQuadrantDisplay');
      // displayElement.innerHTML = `
      //     <div>Quadrant 1: ${quadrant1Drone}</div>
      //     <div>Quadrant 2: ${quadrant2Drone}</div>
      //     <div>Quadrant 3: ${quadrant3Drone}</div>
      //     <div>Quadrant 4: ${quadrant4Drone}</div>
      //     `;
      //   }

      // Object detection image and text
      // Text1: for obj type & Text2: for lighting/illumination
      // var imagesAndTexts = [
      //   { url: "{% static 'img/opticonly_sample.png' %}", text1: "Obj type A - Optic sensor", text2: "Foliage level" },
      //   { url: "{% static 'img/thermal_sample.png' %}", text1: "Obj type B - Thermal image", text2: "Foliage level" },
      //   { url: "{% static 'img/tracer_sample.png' %}", text1: "Obj type C - Tracer image", text2: "Foliage level" },
      //   // ... add more images and texts as needed
      // ];

      //  Object tracker for thermal imaging drones
      // Text1: for obj type & Text2: for lighting/illumination
      var thermalImagesAndTexts = [
        { url: "{% static 'img/thermal/T_LD.png' %}", text1: "Living distractor", text2: "Lighting" },
        { url: "{% static 'img/thermal/T_LT.png' %}", text1: "Living target", text2: "Lighting" },
        { url: "{% static 'img/thermal/T_NLD.png' %}", text1: "Non-living distractor", text2: "Lighting" },
        { url: "{% static 'img/thermal/T_NLT.png' %}", text1: "Non-living target", text2: "Lighting" },
        // ... add more thermal images and texts as needed
      ];

      // Object tracker for N/SWIR imaging drones
      var nswirImagesAndTexts = [
        { url: "{% static 'img/nswir/NS_LD.png' %}", text1: "Living distractor", text2: "Lighting" },
        { url: "{% static 'img/nswir/NS_LT.png' %}", text1: "Living target", text2: "Lighting" },
        { url: "{% static 'img/nswir/NS_NLD.png' %}", text1: "Non-living distractor", text2: "Lighting" },
        { url: "{% static 'img/nswir/NS_NLT.png' %}", text1: "Non-living target", text2: "Lighting" },
        // ... add more N/SWIR images and texts as needed
      ];

      // Function to get a random image and text
      // function getRandomImageAndText() {
      //   var randomIndex = Math.floor(Math.random() * imagesAndTexts.length);
      //   return imagesAndTexts[randomIndex];
      // }

      // Global variable to store the lobject detected type
      let lastDetectedObjectType = '';

      // Global variable to store the last detected object location
      let lastObjectDetectionLocation = null;

      // Function to move drones along their paths
      function moveDrone(drone, droneInfo) {
        const currentLocationIndex = droneInfo.path.findIndex(point =>
          Math.abs(point[0] - drone.geometry.longitude) < 0.00001 &&
          Math.abs(point[1] - drone.geometry.latitude) < 0.00001
        );
        const nextLocationIndex = (currentLocationIndex + 1) % droneInfo.path.length;
        const nextPoint = droneInfo.path[nextLocationIndex];

        if (nextPoint) {
          drone.geometry = new Point({
            longitude: nextPoint[0], // Use the first element of the nextPoint array for longitude
            latitude: nextPoint[1]  // Use the second element of the nextPoint array for latitude
          });
        } else {
          console.error("Next point is undefined. Check the path definition for drone:", drone.attributes.id);
        }

        const detected = droneInfo.objectDetectionPoints.some(detectedPoint =>
          Math.abs(detectedPoint[0] - nextPoint[0]) < 0.00001 &&
          Math.abs(detectedPoint[1] - nextPoint[1]) < 0.00001
        );

        if (detected) {
          // If an object is detected, pause the drone movement
          isAnimating = false;

          //drone that detected the objects
          currentDroneId = drone.attributes.id;

          // If an object is detected, store the location and texts
          // const randomImageAndText = getRandomImageAndText();

          // If an object is detected, store the location and texts
          let randomImageAndText;
          if (droneInfo.imagingType === 'thermal') {
            randomImageAndText = getRandomImageAndText(thermalImagesAndTexts);
          } else if (droneInfo.imagingType === 'nswir') {
            randomImageAndText = getRandomImageAndText(nswirImagesAndTexts);
          }

          // Capture the current timestamp
          const detectionTimestamp = new Date().toISOString();

          // If an object is detected, store the location, timestamp
          lastDetectedObjectInfo = {
              location: {
                // let lastDetectedObjectType = '';
                  longitude: nextPoint[0],
                  latitude: nextPoint[1]
              },
              text1: randomImageAndText.text1, // Store the detected object type
              text2: randomImageAndText.text2,
              timestamp: detectionTimestamp, // Store the timestamp
              droneId: currentDroneId
          };
          console.log("previous type of object detected as stored in text1 in the tracker before global var", lastDetectedObjectInfo.text1);

          // Store the detected object type in the global variable
          lastDetectedObjectType = randomImageAndText.text1;
          console.log("previous type of object detected", lastDetectedObjectType);

          // And display the pop-up with the image of the detected object
          showObjectDetectedPopup("Object detected at " + nextPoint.join(", "), drone.attributes.id, droneInfo.imagingType);

          changeDroneColorOnDetection(drone);
        }
      }

      // Function to get a random image and text
      function getRandomImageAndText(imagesAndTexts) {
        var randomIndex = Math.floor(Math.random() * imagesAndTexts.length);
        return imagesAndTexts[randomIndex];
      }

      // Function to update the "drone control" UI
      function updateDroneControlUI(droneName, imageText1, imageText2) {
        // Select the paragraph elements for the "Current drone:", "Object detected:", and "Foliage density:"
        const currentDroneElement = document.querySelector('#current-drone');
        const objectDetectedElement = document.querySelector('#object-detected');
        const foliageDensityElement = document.querySelector('#foliage-density');

        // Update their text content with the name of the drone and the image texts
        currentDroneElement.textContent = `Current drone: ${droneName}`;
        objectDetectedElement.textContent = `Object detected: ${imageText1}`;
        foliageDensityElement.textContent = `Foliage density: ${imageText2}`;
      }

      //Function for pop-up of object detected
     function showObjectDetectedPopup(message, droneName, imagingType) {
       let imageAndText;
       if (imagingType === 'thermal') {
         imageAndText = thermalImagesAndTexts.find(item => item.text1 === lastDetectedObjectType);
       } else if (imagingType === 'nswir') {
         imageAndText = nswirImagesAndTexts.find(item => item.text1 === lastDetectedObjectType);
       }

       // If no matching object type is found, log an error and return
       if (!imageAndText) {
         console.error('No image and text found for the last detected object type:', lastDetectedObjectType);
         return;
       }

       var imageUrl = imageAndText.url;
       var imageText1 = imageAndText.text1; // This should match lastDetectedObjectType
       var imageText2 = imageAndText.text2;

       console.log("previous type of object detected saved in pop-up OG", imageText1);

       const popup = document.createElement("div");
       const image = document.createElement("img");
       image.src = imageUrl;
       image.alt = "Detected Object";
       image.style.width = "400px"; // Set the width of the image
       image.style.height = "400px"; // Set the height of the image
       image.style.display = "block"; // Display the image as a block element
       image.style.marginBottom = "10px"; // Margin below the image

       const textNode1 = document.createTextNode(message + " by " + droneName + imageText1); //Message appearing when object detected
       const textNode2 = document.createTextNode(imageText2);
       popup.appendChild(image); // Append the image to the popup
       popup.appendChild(textNode1); // Append the text message to the popup - from image text1
       popup.appendChild(document.createElement("br")); // Line break between texts
       popup.appendChild(textNode2); // Append the text message to the popup - from image text2

       popup.style.position = "absolute";
       popup.style.left = "50%";
       popup.style.top = "50%";
       popup.style.transform = "translate(-50%, -50%)";
       popup.style.backgroundColor = "white";
       popup.style.padding = "10px";
       popup.style.border = "1px solid black";
       popup.style.zIndex = "1000"; // Ensure the popup is above other elements

       document.body.appendChild(popup);

       // Automatically close the popup after 10 seconds
       setTimeout(() => {
         document.body.removeChild(popup);
       }, 10000);

       // Update the drone control UI with the name of the drone that detected the object
       updateDroneControlUI(droneName, imageText1, imageText2);
     }

      // //Start-stop search
      // const startButton = document.getElementById('startsearchbutton');
      // const stopButton = document.getElementById('stopsearchbutton');

         // Animation function to update point positions
      let animationFrameId;
      let isAnimating = false;

      function animate() {
        if (!isAnimating) {
          return;
        }

        // const delayInMilliseconds = 10000; // Set the desired delay

        pointGraphics.forEach(graphic => {
            const droneId = graphic.attributes.id;
            const droneInfo = dronePathsTrack[droneId];


            if (droneInfo.recentlyReassigned) {
                const timeSinceReassignment = Date.now() - droneInfo.reassignmentTime;
                if (timeSinceReassignment < droneInfo.delay) {
                    // Skip animation for this drone if the delay period has not yet passed
                    return;
                } else {
                    // Reset the flag once the delay period has passed
                    droneInfo.recentlyReassigned = false;
                }
            }

            // const dronePath = droneInfo.path;
            if (droneInfo && droneInfo.path && droneInfo.path.length > 0) {
                moveDrone(graphic, droneInfo);
            } else {
                console.warn(`No path found for drone with id: ${droneId}`);
            }
          });

        // Refresh the graphics on the view
        view.graphics.removeAll();
        view.graphics.addMany([...quadrant1, ...quadrant2, ...quadrant3, ...quadrant4, ...pointGraphics, XaxisGraphic, YaxisGraphic]);

        // Request the next frame in the animation with a delay
        setTimeout(() => {
          animationFrameId = requestAnimationFrame(animate);
        }, 0.35 * 1000); // Delay in milliseconds (0.35 seconds per movement)
      }

   // Object detection task reassignment to another drone
   function reassignTaskToDrone(currentDroneId, newDroneId) {
     // Swap quadrant info of drones
     // let temp = dronePathsTrack[currentDroneId]
     // dronePathsTrack[currentDroneId] = dronePathsTrack[newDroneId];
     // dronePathsTrack[newDroneId] = temp;
     let tempQuadrant = dronePathsTrack[currentDroneId].quadrant; // Temporarily store current drone's quadrant

     // Swap paths, object detection points of drones
     let tempPath = dronePathsTrack[currentDroneId].path;
     let tempObjectDetectionPoints = dronePathsTrack[currentDroneId].objectDetectionPoints;
     let currentDroneLocation = pointGraphics.find(graphic => graphic.attributes.id === currentDroneId).geometry;
     let newDroneLocation = pointGraphics.find(graphic => graphic.attributes.id === newDroneId).geometry;

     dronePathsTrack[currentDroneId].path = dronePathsTrack[newDroneId].path;
     dronePathsTrack[currentDroneId].objectDetectionPoints = dronePathsTrack[newDroneId].objectDetectionPoints;
     dronePathsTrack[currentDroneId].quadrant = dronePathsTrack[newDroneId]. quadrant // Assign new drone's quadrant to current drone

     dronePathsTrack[newDroneId].path = tempPath;
     dronePathsTrack[newDroneId].objectDetectionPoints = tempObjectDetectionPoints;
     dronePathsTrack[newDroneId].quadrant = tempQuadrant; // Assign temp (original current drone's) quadrant to new drone

     // // Calculate the distance between the two drones
     // let currentDroneLocation = pointGraphics.find(graphic => graphic.attributes.id === currentDroneId).geometry;
     // let newDroneLocation = pointGraphics.find(graphic => graphic.attributes.id === newDroneId).geometry;
     let distance = calculateDistance(currentDroneLocation, newDroneLocation);

     // Set a proportional delay based on the distance
     let delayInMilliseconds = distance * 1000; // 1000 ms /1 second per unit distance

     // Set a reassignment flag and timestamp for both drones
     dronePathsTrack[currentDroneId].recentlyReassigned = true;
     dronePathsTrack[currentDroneId].reassignmentTime = Date.now();
     dronePathsTrack[currentDroneId].delay = delayInMilliseconds;
     dronePathsTrack[newDroneId].recentlyReassigned = true;
     dronePathsTrack[newDroneId].reassignmentTime = Date.now();
     dronePathsTrack[newDroneId].delay = delayInMilliseconds;

     // Move the new drone to the current drone's previous location
     moveDroneToPoint(newDroneId, [currentDroneLocation.longitude, currentDroneLocation.latitude]);

     // Move the current drone to the new drone's previous location
     moveDroneToPoint(currentDroneId, [newDroneLocation.longitude, newDroneLocation.latitude]);

     // Update the map with the new positions
     updateMap();
     updateQuadrantDisplay();
   }

   function calculateDistance(location1, location2) {
     // Distance calculation between two points, replace with actual distance calculation
     // Euclidean distance calculation
     let dx = location1.longitude - location2.longitude;
     let dy = location1.latitude - location2.latitude;
     return Math.sqrt(dx * dx + dy * dy);
   }

   function moveDroneToPoint(droneId, point) {
     // Find the drone graphic by id
     const droneGraphic = pointGraphics.find(graphic => graphic.attributes.id === droneId);
     if (droneGraphic && point) {
       // Update the drone's location
       droneGraphic.geometry = new Point({
         longitude: point[0], // Use the first element of the point array for longitude
         latitude: point[1] // Use the second element of the point array for latitude
       });
     //   // Refresh the graphics on the view
     //   view.graphics.removeAll();
     //   view.graphics.addMany([...quadrant1, ...quadrant2, ...quadrant3, ...quadrant4, ...pointGraphics, XaxisGraphic, YaxisGraphic]);
     } else {
       console.error(`Drone with id ${droneId} or point is undefined`);
     }
   } // Update the UI or map to reflect the new positions and assignments

   // Function to show pop-up for re-detected object by new/reassigned drone
   function showRedetectedObjectPopup(droneName, imagingType, callback) {
     // Stop all drones before showing the pop-up
     isAnimating = false;
     cancelAnimationFrame(animationFrameId);

     let selectedImagesAndTexts;
     // let selectedImagesAndTexts = imagingType === 'thermal' ? thermalImagesAndTexts : nswirImagesAndTexts;

     // Assign array to selectedImagesAndTexts based on the imagingType
     if (imagingType === 'thermal') {
       selectedImagesAndTexts = thermalImagesAndTexts;
     } else if (imagingType === 'nswir') {
       selectedImagesAndTexts = nswirImagesAndTexts;
     } else {
       console.error('Invalid imaging type:', imagingType);
       return;
     }

     // Find the image and text that match the last detected object type
     const matchingImageAndText = selectedImagesAndTexts.find(item => item.text1 === lastDetectedObjectType);
     if (!matchingImageAndText) {
       console.error('No matching image and text found for the last detected object type:', lastDetectedObjectType);
       return;
     }

      // Generate the pop-up using the matching image and text
     const imageUrl = matchingImageAndText.url;
     const imageText1 = matchingImageAndText.text1;
     const imageText2 = matchingImageAndText.text2;

     const popup = document.createElement("div");
     const image = document.createElement("img");
     image.src = imageUrl;
     image.alt = "Detected Object";
     image.style.width = "400px";
     image.style.height = "400px";
     image.style.display = "block";
     image.style.marginBottom = "10px";

     const message = "Re-detected object: ";
     const textNode1 = document.createTextNode(message + " by " + droneName + ": " + imageText1);
     const textNode2 = document.createTextNode(imageText2);
     popup.appendChild(image);
     popup.appendChild(textNode1);
     popup.appendChild(document.createElement("br"));
     popup.appendChild(textNode2);

     popup.style.position = "absolute";
     popup.style.left = "50%";
     popup.style.top = "50%";
     popup.style.transform = "translate(-50%, -50%)";
     popup.style.backgroundColor = "white";
     popup.style.padding = "10px";
     popup.style.border = "1px solid black";
     popup.style.zIndex = "1000";

     document.body.appendChild(popup);

     setTimeout(() => {
       document.body.removeChild(popup);
       if (typeof callback === "function") {
         callback(); // Call the callback function to reset reassignedDroneId
       }
     }, 10000);

     // Update the drone control UI with the name of the drone that detected the object
     updateDroneControlUI(droneName, imageText1, imageText2);
   }

      // Event listener for the Start Search button
      document.getElementById('startsearchbutton').addEventListener('click', function() {
        isAnimating = true;
        cancelAnimationFrame(animationFrameId);
        animate();

        // Use the reassignedDroneId as the activeDroneId
        let activeDroneId = reassignedDroneId; // This is set when the user reassigns a drone
        if (activeDroneId) {
          let activeDroneInfo = dronePathsTrack[activeDroneId];
          let imagingType = activeDroneInfo.imagingType;

          // Show the pop-up for the re-detected object with the correct imaging type
          // Pass a callback function to reset reassignedDroneId after the pop-up is closed
          showRedetectedObjectPopup(activeDroneId, imagingType, function() {
            reassignedDroneId = ''; // Reset reassignedDroneId after the pop-up is closed
          });
        } else {
          console.error('No drone has been reassigned yet.');
        }

        // Hide the Initial drone assignment
        document.getElementById('droneSelectionForm').style.display = 'none';
        // Hide the reassignment options
        document.getElementById('reassignToDroneSection').style.display = 'none';
        // Show the quadrant display
        document.getElementById('droneQuadrantDisplay').style.display = 'block';
        // Hide the recayegorization of drone recommendation
        document.getElementById('recategorizeObject').style.display = 'none';
        // Update the display with the current drone assignments
        updateQuadrantDisplay();

      });

      // Event listener for the Stop Search button
      document.getElementById('stopsearchbutton').addEventListener('click', function() {
        isAnimating = false;
      });

      // Event listener for the Submit button (Initial assignment)
      document.getElementById('submitBtn').addEventListener('click', function() {
        // event.preventDefault();
        updateQuadrantDisplay();
    });

      // Event listener for the 'Yes' button in task assignment
      document.getElementById('yesBtn').addEventListener('click', function() {
        document.getElementById('reassignToDroneSection').style.display = 'block';
        userReassignResponse = 'Yes';
      });

      // Event listener for the 'No' button in task assignment
      document.getElementById('noBtn').addEventListener('click', function() {
        document.getElementById('reassignToDroneSection').style.display = 'none';
        userReassignResponse = 'No';
      });

      // Event listener for the 'Reassign' button
      document.getElementById('reassignBtn').addEventListener('click', function() {
        const newDroneId = document.getElementById('sel_drone').value;
        reassignedDroneId = newDroneId;
        reassignTaskToDrone(currentDroneId, newDroneId);
        updateQuadrantDisplay();
      });

    // //Search funtion
    //  const search = new Search({
    //          view: view
    //        });

     // Function to update the displayed value of the competence rating
     function updateCompetenceValue(value, droneNumber) {
      document.getElementById('competenceValue' + droneNumber).textContent = value;
    }

    // Function to update the displayed value of the trust rating
    function updateTrustValue(value, droneNumber) {
      document.getElementById('trustValue' + droneNumber).textContent = value;
    }

    // Event listener for the competence slider
    for (let i = 1; i <= 4; i++) {
      document.getElementById('competenceRange' + i).addEventListener('input', function() {
        updateCompetenceValue(this.value, i);
      });

      // Event listeners for the trust sliders
         document.getElementById('trustRange' + i).addEventListener('input', function() {
           updateTrustValue(this.value, i);
         });
       }

       // // Collect values from sliders,...
       // function collectValues() {
       //   const data = [];
       //   // Assuming you have 4 drones based on the provided HTML structure
       //   for (let i = 1; i <= 4; i++) {
       //     const trustValue = document.getElementById(`trustValue${i}`).textContent;
       //     const competenceValue = document.getElementById(`competenceValue${i}`).textContent;
       //     data.push({ id: i, trustValue, competenceValue });
       //   }
       //   return data;
       // }

       // // Convert data to CSV
       // function convertToCSV(data) {
       //   const csvRows = ['id,trust,competence'];
       //   data.forEach(row => {
       //     csvRows.push(`${row.id},${row.trustValue},${row.competenceValue}`);
       //   });
       //   return csvRows.join('\n');
       // }

       // document.getElementById('exportButton').addEventListener('click', function() {
       //   const data = collectValues();
       //   const csvData = convertToCSV(data);
       //   downloadCSV(csvData);
       // });

       // Array to store the ratings
       let ratings = [];

       // Variable to store user response to recommendation
       let userResponse = '';

       // Variable to store user response to reassignment
       let userReassignResponse = '';
       let reassignedDroneId = '';

       function saveRatings() {
           // Retrieve the current ratings for each drone
           let currentRatings = [];
           for (let i = 1; i <= 4; i++) { // Assuming you have 4 drones
               let trust = document.getElementById(`trustRange${i}`).value;
               let competence = document.getElementById(`competenceRange${i}`).value;
               currentRatings.push({drone: i, trust: trust, competence: competence});
           }
           // Retrieve the recategorized object from the select element
           let userReobject = document.getElementById('sel_obj').value;

           // Save the current ratings to the array
           ratings.push({
             ratings: currentRatings,
             response: userResponse,
             reassignResponse: userReassignResponse,
             userReobject: userReobject,
             detectedObjectInfo: lastDetectedObjectInfo,
             reassignedDroneId: reassignedDroneId
             });
           console.log('Drone ratings saved:', currentRatings); // For debugging
           console.log('User response saved:', userResponse);
           console.log('User recategorization saved:', userReobject);
           console.log('User recategorization saved:', userReassignResponse);

           // Reset user response after saving
           userResponse = '';
           // reassignedDroneId = '';
           userReassignResponse = '';
           document.getElementById('sel_obj').value = '';
           lastDetectedObjectInfo = null;
       }

       function exportToCSV() {
           let csvContent = "data:text/csv;charset=utf-8,";

           // Check if there is a reassignment timestamp to include
           if (reassignmentTimestamp) {
               // Add a separator and headers for the reassignment timestamp
               csvContent += "Initial assignment\n";
               // Add the reassignment timestamp as a separate row
               csvContent += `${reassignmentTimestamp}\n\n`;
           }

           csvContent += "Detection timestamp, Obj detected location, Detecting drone, Object detected, Lighting, User Response to recommendation, Re-categorized Object, Task Reassigned, Reassigned Drone, Drone ID, Trust, Competence\n"; // Header
           ratings.forEach((entry, sessionIndex) => {
               entry.ratings.forEach((rating, ratingIndex) => {
                   // Include the user response to object detection and reassigment only on the first drone rating of each session
                   if (ratingIndex === 0) {
                     const detectionInfo = entry.detectedObjectInfo || {};
                     // Concatenate longitude and latitude into a single string
                     const locationString = detectionInfo.location ? `${detectionInfo.location.longitude},${detectionInfo.location.latitude}` : '';
                     const text1 = detectionInfo.text1 || '';
                     const text2 = detectionInfo.text2 || '';
                     const timestamp = detectionInfo.timestamp || '';
                     const detectingDrone = detectionInfo.droneId || ''; // Get the detecting drone's ID
                     csvContent += `"${timestamp}","${locationString}","${detectingDrone}","${text1}","${text2}",${entry.response},${entry.userReobject},"${entry.reassignResponse}","${entry.reassignedDroneId}",${rating.drone},${rating.trust},${rating.competence}\n`;
                   } else {
                     csvContent += `,,,,,,,,,${rating.drone},${rating.trust},${rating.competence}\n`;
                   }
               });
               // Add a separator between sessions if needed
               if (sessionIndex < ratings.length - 1) {
                   csvContent += "\n";
               }
           });

           var encodedUri = encodeURI(csvContent);
           var link = document.createElement("a");
           link.setAttribute("href", encodedUri);
           link.setAttribute("download", "drone_ratings.csv");
           document.body.appendChild(link); // Required for FF
           link.click(); // This will download the file
       }

       // //
       // function downloadCSV(csvData) {
       //   const blob = new Blob([csvData], { type: 'text/csv' });
       //   const url = window.URL.createObjectURL(blob);
       //   const a = document.createElement('a');
       //   a.setAttribute('hidden', '');
       //   a.setAttribute('href', url);
       //   a.setAttribute('download', 'drone_ratings.csv');
       //   document.body.appendChild(a);
       //   a.click();
       //   document.body.removeChild(a);
       // }

       // Event listener for confirm ratings for given round of detection
       document.getElementById('confirmButton').addEventListener('click', saveRatings);

       // Event listener for Exporting to CSV button
       document.getElementById('exportButton').addEventListener('click', exportToCSV);

       // Event listener for user response for recategorized object recommendation
       document.getElementById('accept-recommendation').addEventListener('click', function() {
           userResponse = 'Accept';
           document.getElementById('recategorizeObject').style.display = 'none';
       });

       document.getElementById('reject-recommendation').addEventListener('click', function() {
           userResponse = 'Reject';
           document.getElementById('recategorizeObject').style.display = 'block';
       });

       // Event listener for re-categorize object selection
       document.getElementById('sel_obj').addEventListener('input', function() {
           userReobject = '';
       });

     //places the logo div in the bottom right corner of the view
     // view.ui.add("logoDiv", "bottom-right");

     // // places the search widget in the top right corner of the view
     // view.ui.add(search, "top-right");

     // places the initial drone-assignment widget in the top right corner of the view
     view.ui.add("droneSelectionForm", "top-right");

     // places the drone-control widget in the top right corner of the view
     view.ui.add("droneControl", "top-right");

     // places the drone-ratings widget in the bottom of the view
     view.ui.add("droneRatings", "top-left");

     // places the current drone-assignment widget in the top right corner of the view
     view.ui.add("droneQuadrantDisplay", "top-right");

         });

  </script>

</head>

<body>
       <div id="viewDiv"></div>

       <!-- <div id="logoDiv">SCEL/VT</div> -->

       <form id="droneSelectionForm">
         <hr>
          <h3 class="main-heading">Initial Drone assignment</h3>
             <!-- <hr> -->
          <div>
         <label for="quadrant1">Quadrant 1:</label>
         <select id="quadrant1" name="quadrant1">
           <option value="drone1" selected>Drone 1</option>
           <option value="drone2">Drone 2</option>
           <option value="drone3">Drone 3</option>
           <option value="drone4">Drone 4</option>
         </select>
       </div>
       <div>
         <label for="quadrant2">Quadrant 2:</label>
         <select id="quadrant2" name="quadrant2">
           <option value="drone1">Drone 1</option>
           <option value="drone2" selected>Drone 2</option>
           <option value="drone3">Drone 3</option>
           <option value="drone4">Drone 4</option>
         </select>
       </div>
       <div>
         <label for="quadrant3">Quadrant 3:</label>
         <select id="quadrant3" name="quadrant3">
           <option value="drone1">Drone 1</option>
           <option value="drone2">Drone 2</option>
           <option value="drone3" selected>Drone 3</option>
           <option value="drone4">Drone 4</option>
         </select>
       </div>
       <div>
         <label for="quadrant4">Quadrant 4:</label>
         <select id="quadrant4" name="quadrant4">
           <option value="drone1">Drone 1</option>
           <option value="drone2">Drone 2</option>
           <option value="drone3">Drone 3</option>
           <option value="drone4" selected>Drone 4</option>
         </select>
       </div>
         <input id="submitBtn" type="submit" value="Submit">
       </form>

       <div id="droneQuadrantDisplay">
         <hr>
         <h3 class="main-heading">Current Drone assignment</h3>
            <hr>
         <!-- <div class="quadrant-info" id="quadrant1Info">Quadrant 1: </div>
         <div class="quadrant-info" id="quadrant2Info">Quadrant 2: </div>
         <div class="quadrant-info" id="quadrant3Info">Quadrant 3: </div>
         <div class="quadrant-info" id="quadrant4Info">Quadrant 4: </div> -->
       </div>

       <div id="droneControl" class="droneControl-container">
         <!-- <h2 class="main-heading">Drone control and Object detection</h2> -->
           <!-- <hr> -->

         <!-- <div>
           <h4 class="current-drone">Current drone: </h3>
           <h4 class="foliage-density">Foligage density: </h3>
             <hr> -->
             <!-- <hr> -->
           <h3 class="drone-motion">Drone Control Tools</h3>
           <div>
             <label >Object Search: </label>
             <input type="button" class="start-button" value="Start" id="startsearchbutton">
             <input type="button" class="stop-button" value="Stop" id="stopsearchbutton">
           </div>
          <hr>

           <div>
           <h3 class="detection-info">Object detection</h3>
             <p id="current-drone">Current drone:</p>
             <p id="foliage-density">Foliage density:</p>
             <p id="object-detected">Object detected:</p>
           </div>
           <div>
             <label >Object Recommendation:</label>
             <div>
             <input type="button" class="yes-button" value="Accept" id="accept-recommendation" />
             <input type="button" class="no-button" value="Reject" id="reject-recommendation" />
           </div>
           </div>

           <!-- <div>
             <input type="text" class="bt_save_edit" id="tasknotes" value="Task_name"/>
             <input type="button" class="bt_save" value="Save Task" id="savetasks"/>
           </div> -->

           <div id="recategorizeObject" style="display:none">
             <label >Re-categorize object: </label>
             <select id="sel_obj">
               <option value="living target">Living target</option>
               <option value="non-living target">Non-living target</option>
               <option value="living distractor">Living distractor</option>
               <option value="non-living distractor">Non-living distractor</option>
             </select>
             <!-- <input type="button" id="confirmObjCat" value="Confirm" /> -->
           </div>
             <hr>

             <div>
             <h3 class="detection-info">Task assignment</h3>
               <!-- <p id="current-drone">Current drone:</p> -->
             </div>
             <div id="resassignTaskSection">
               <label >Re-assign task:</label>
               <input type="button" class="yes-button" value="Yes" id="yesBtn" />
               <input type="button" class="no-button" value="No" id="noBtn" />
             </div>
             <div id="reassignToDroneSection" style="display:none;">
               <label >Re-assign task to: </label>
               <select id="sel_drone">
                 <option value="drone1">Drone 1</option>
                 <option value="drone2">Drone 2</option>
                 <option value="drone3">Drone 3</option>
                 <option value="drone4">Drone 4</option>
               </select>
               <input type="button" id="reassignBtn" value="Reassign/Swap" />
             </div>

       <!-- change label class for each drone type -->
       <div id="droneRatings" class="droneRatings-container">
         <!-- <hr> -->
         <h3 class="list-heading">Drone competence ranking</h3>
         <div class="droneRatings-container">
         <!-- <hr> -->
         <!-- <label><strong> Drone 1: </strong></label> -->
         <div class="slider-group">
               <label for="competenceRange1">Drone1: </label>
               <input type="range" min="1" max="4" value="3" class="competence-slider" id="competenceRange1" list="tickmarks1">
               <datalist id="tickmarks1">
                 <option value="1" label="1st"></option>
                 <option value="2" label="2nd"></option>
                 <option value="3" label="3rd"></option>
                 <option value="4" label="4th"></option>
               </datalist>
               <!-- <span id="competenceValue1">3</span> -->
             </div>
             <div class="slider-group">
               <label for="competenceRange2">Drone2: </label>
               <input type="range" min="1" max="4" value="3" class="competence-slider" id="competenceRange2" list="tickmarks2">
               <datalist id="tickmarks2">
                 <option value="1" label="1st"></option>
                 <option value="2" label="2nd"></option>
                 <option value="3" label="3rd"></option>
                 <option value="4" label="4th"></option>
               </datalist>
               <!-- <span id="competenceValue2">3</span> -->
             </div>
             <div class="slider-group">
               <label for="competenceRange3">Drone3: </label>
               <input type="range" min="1" max="4" value="3" class="competence-slider" id="competenceRange3" list="tickmarks3">
               <datalist id="tickmarks3">
                 <option value="1" label="1st"></option>
                 <option value="2" label="2nd"></option>
                 <option value="3" label="3rd"></option>
                 <option value="4" label="4th"></option>
               </datalist>
               <!-- <span id="competenceValue3">3</span> -->
             </div>
             <div class="slider-group">
               <label for="competenceRange4">Drone4: </label>
               <input type="range" min="1" max="4" value="3" class="competence-slider" id="competenceRange4" list="tickmarks4">
               <datalist id="tickmarks4">
                 <option value="1" label="1st"></option>
                 <option value="2" label="2nd"></option>
                 <option value="3" label="3rd"></option>
                 <option value="4" label="4th"></option>
               </datalist>
               <!-- <span id="competenceValue4">3</span> -->
             </div>
         </div>
         <hr>
         <div>
         <!-- <label><strong> Drone 2: </strong></label> -->
         <h3 class="list-heading">Drone trust rating</h3>
             <div class="slider-group">
               <label for="trustRange1">Drone1: </label>
               <input type="range" min="1" max="5" value="3" class="slider" id="trustRange1">
               <span id="trustValue1">3</span>
             </div>
             <div class="slider-group">
               <label for="trustRange2">Drone2: </label>
               <input type="range" min="1" max="5" value="3" class="slider" id="trustRange2">
               <span id="trustValue2">3</span>
             </div>
             <div class="slider-group">
               <label for="trustRange3">Drone3: </label>
               <input type="range" min="1" max="5" value="3" class="slider" id="trustRange3">
               <span id="trustValue3">3</span>
             </div>
             <div class="slider-group">
               <label for="trustRange4">Drone4: </label>
               <input type="range" min="1" max="5" value="3" class="slider" id="trustRange4">
               <span id="trustValue4">3</span>
             </div>
         </div>
         <hr>
         <div>
           <label for="confirmButton">Confirm Ratings </label>
           <button id="confirmButton">Confirm</button>
         </div>
         <hr>
         <div>
           <label for="trustRange4">Export to CSV </label>
           <button id="exportButton">Export to CSV</button>
         </div>

       </div>

</body>
</html>
